/**
 * @file ChatRoomPlugin.cpp
 *
 * This is a plug-in for the Excalibur web server, designed
 * to demonstrate a simple chat-room type application.
 *
 * Â© 2018 by Richard Walters
 */

#include <functional>
#include <Http/Server.hpp>
#include <inttypes.h>
#include <Json/Json.hpp>
#include <map>
#include <mutex>
#include <string>
#include <SystemAbstractions/StringExtensions.hpp>
#include <WebServer/PluginEntryPoint.hpp>
#include <WebSockets/WebSocket.hpp>

#ifdef _WIN32
#define API __declspec(dllexport)
#else /* POSIX */
#define API
#endif /* _WIN32 / POSIX */

namespace {

    /**
     * This represents one user in the chat room.
     */
    struct User {
        // Properties

        /**
         * This is the nickname to show for the user.
         */
        std::string nickname;

        /**
         * This is the web socket connection to the user.
         */
        WebSockets::WebSocket ws;

        // Methods

    };

    /**
     * This represents the state of the chat room.
     */
    struct Room {
        // Properties

        /**
         * This is used to synchronize access to the chat room.
         */
        std::mutex mutex;

        /**
         * These are the users currently in the chat room,
         * keyed by session ID.
         */
        std::map< unsigned int, User > users;

        /**
         * This is the next session ID that may be assigned
         * to a new user.
         */
        unsigned int nextSessionId = 1;

        // Methods

        /**
         * This method is called whenever a new user tries
         * to connect to the chat room.
         *
         * @param[in] request
         *     This is the request to connect to the chat room.
         *
         * @param[in] connection
         *     This is the connection on which the request was made.
         *
         * @return
         *     The response to be returned to the client is returned.
         */
        std::shared_ptr< Http::Response > AddUser(
            std::shared_ptr< Http::Request > request,
            std::shared_ptr< Http::Connection > connection
        ) {
            std::lock_guard< decltype(mutex) > lock(mutex);
            const auto response = std::make_shared< Http::Response >();
            const auto sessionId = nextSessionId++;
            auto& user = users[sessionId];
            if (
                !user.ws.OpenAsServer(
                    connection,
                    *request,
                    *response
                )
            ) {
                (void)users.erase(sessionId);
            }
            return response;
        }
    } room;

}

/**
 * This is the entry point function of the plug-in.
 *
 * @param[in,out] server
 *     This is the server to which to add the plug-in.
 *
 * @param[in] configuration
 *     This holds the configuration items of the plug-in.
 *
 * @param[in] delegate
 *     This is the function to call to deliver diagnostic
 *     messages generated by the plug-in.
 *
 * @param[out] unloadDelegate
 *     This is where the plug-in should store a function object
 *     that the server should call to stop and clean up the plug-in
 *     just prior to unloading it.
 *
 *     If this is set to nullptr on return, it means the plug-in
 *     was unable to load successfully.
 */
extern "C" API void LoadPlugin(
    Http::IServer* server,
    Json::Json configuration,
    SystemAbstractions::DiagnosticsSender::DiagnosticMessageDelegate diagnosticMessageDelegate,
    std::function< void() >& unloadDelegate
) {
    // Determine the resource space we're serving.
    Uri::Uri uri;
    if (!configuration.Has("space")) {
        diagnosticMessageDelegate(
            "",
            SystemAbstractions::DiagnosticsSender::Levels::ERROR,
            "no 'space' URI in configuration"
        );
        return;
    }
    if (!uri.ParseFromString(configuration["space"])) {
        diagnosticMessageDelegate(
            "",
            SystemAbstractions::DiagnosticsSender::Levels::ERROR,
            "unable to parse 'space' URI in configuration"
        );
        return;
    }
    auto space = uri.GetPath();
    (void)space.erase(space.begin());

    // Register to handle requests for the space we're serving.
    const auto unregistrationDelegate = server->RegisterResource(
        space,
        [](
            std::shared_ptr< Http::Request > request,
            std::shared_ptr< Http::Connection > connection
        ){
            return room.AddUser(request, connection);
        }
    );

    // Give back the delete to call just before this plug-in is unloaded.
    unloadDelegate = [unregistrationDelegate]{
        unregistrationDelegate();
    };
}

/**
 * This checks to make sure the plug-in entry point signature
 * matches the entry point type declared in the web server API.
 */
namespace {
    PluginEntryPoint EntryPoint = &LoadPlugin;
}
